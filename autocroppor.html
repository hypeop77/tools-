<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BatchDocCropper - AI-Powered Document Cropping</title>
    <style>
        :root {
            --primary-color: #3a86ff;
            --primary-dark: #2667cc;
            --secondary-color: #8338ec;
            --success-color: #06d6a0;
            --warning-color: #ffd166;
            --error-color: #ef476f;
            --bg-color: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-tertiary: #e9ecef;
            --text-color: #212529;
            --text-secondary: #6c757d;
            --border-color: #dee2e6;
            --border-radius: 8px;
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s ease;
        }

        [data-theme="dark"] {
            --bg-color: #121212;
            --bg-secondary: #1e1e1e;
            --bg-tertiary: #2d2d2d;
            --text-color: #e9ecef;
            --text-secondary: #adb5bd;
            --border-color: #404040;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            transition: var(--transition);
        }

        .app {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        /* Header Styles */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 2rem;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--bg-secondary);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 700;
            font-size: 1.5rem;
            color: var(--primary-color);
        }

        .logo-icon {
            width: 32px;
            height: 32px;
            background-color: var(--primary-color);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        .header-actions {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: 500;
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }

        .btn-primary:hover {
            background-color: var(--primary-dark);
        }

        .btn-secondary {
            background-color: var(--bg-tertiary);
            color: var(--text-color);
        }

        .btn-secondary:hover {
            background-color: var(--border-color);
        }

        .btn-icon {
            padding: 0.5rem;
            background: transparent;
            border: none;
            cursor: pointer;
            color: var(--text-color);
            border-radius: var(--border-radius);
            transition: var(--transition);
        }

        .btn-icon:hover {
            background-color: var(--bg-tertiary);
        }

        /* Main Content Styles */
        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Sidebar Styles */
        .sidebar {
            width: 300px;
            background-color: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .sidebar-header {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .file-counter {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .file-list {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
        }

        .file-item {
            display: flex;
            padding: 0.75rem;
            border-radius: var(--border-radius);
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: var(--transition);
            border: 1px solid transparent;
        }

        .file-item:hover {
            background-color: var(--bg-tertiary);
        }

        .file-item.active {
            border-color: var(--primary-color);
            background-color: rgba(58, 134, 255, 0.1);
        }

        .file-thumbnail {
            width: 50px;
            height: 50px;
            border-radius: 4px;
            background-color: var(--bg-tertiary);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            margin-right: 0.75rem;
            flex-shrink: 0;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .file-thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .file-info {
            flex: 1;
            overflow: hidden;
        }

        .file-name {
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 0.25rem;
        }

        .file-details {
            font-size: 0.75rem;
            color: var(--text-secondary);
            display: flex;
            justify-content: space-between;
        }

        .file-status {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.75rem;
        }

        .status-badge {
            padding: 0.125rem 0.5rem;
            border-radius: 12px;
            font-size: 0.625rem;
            font-weight: 500;
        }

        .status-waiting {
            background-color: var(--bg-tertiary);
            color: var(--text-secondary);
        }

        .status-processing {
            background-color: var(--warning-color);
            color: #000;
        }

        .status-done {
            background-color: var(--success-color);
            color: white;
        }

        .status-error {
            background-color: var(--error-color);
            color: white;
        }

        /* Editor Styles */
        .editor {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .editor-header {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .editor-title {
            font-weight: 600;
        }

        .editor-actions {
            display: flex;
            gap: 0.5rem;
        }

        .editor-content {
            flex: 1;
            display: flex;
            overflow: hidden;
            position: relative;
        }

        .canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: auto;
            padding: 1rem;
            background-color: var(--bg-tertiary);
            position: relative;
        }

        #editor-canvas {
            max-width: 100%;
            max-height: 100%;
            box-shadow: var(--shadow);
            background-color: white;
            cursor: crosshair;
        }

        .crop-list {
            width: 250px;
            border-left: 1px solid var(--border-color);
            background-color: var(--bg-secondary);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .crop-list-header {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .crop-items {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
        }

        .crop-item {
            display: flex;
            padding: 0.75rem;
            border-radius: var(--border-radius);
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: var(--transition);
            border: 1px solid transparent;
        }

        .crop-item:hover {
            background-color: var(--bg-tertiary);
        }

        .crop-item.active {
            border-color: var(--primary-color);
            background-color: rgba(58, 134, 255, 0.1);
        }

        .crop-thumbnail {
            width: 50px;
            height: 50px;
            border-radius: 4px;
            background-color: var(--bg-tertiary);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            margin-right: 0.75rem;
            flex-shrink: 0;
        }

        .crop-thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .crop-info {
            flex: 1;
            overflow: hidden;
        }

        .crop-name {
            font-weight: 500;
            margin-bottom: 0.25rem;
        }

        .crop-details {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .crop-actions {
            display: flex;
            gap: 0.25rem;
        }

        /* Upload Area Styles */
        .upload-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            text-align: center;
        }

        .upload-icon {
            width: 80px;
            height: 80px;
            background-color: var(--bg-tertiary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 1.5rem;
            color: var(--primary-color);
            font-size: 2rem;
        }

        .upload-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .upload-description {
            color: var(--text-secondary);
            margin-bottom: 2rem;
            max-width: 500px;
        }

        .upload-zone {
            width: 100%;
            max-width: 500px;
            border: 2px dashed var(--border-color);
            border-radius: var(--border-radius);
            padding: 2rem;
            transition: var(--transition);
            cursor: pointer;
        }

        .upload-zone:hover, .upload-zone.drag-over {
            border-color: var(--primary-color);
            background-color: rgba(58, 134, 255, 0.05);
        }

        .upload-formats {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-top: 1rem;
        }

        /* Footer Styles */
        .footer {
            padding: 1rem 2rem;
            border-top: 1px solid var(--border-color);
            background-color: var(--bg-secondary);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .summary {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 1rem;
        }

        .modal {
            background-color: var(--bg-color);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            width: 100%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            padding: 1.5rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-weight: 600;
            font-size: 1.25rem;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-secondary);
        }

        .modal-body {
            padding: 1.5rem;
            flex: 1;
            overflow-y: auto;
        }

        .modal-footer {
            padding: 1rem 1.5rem;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: flex-end;
            gap: 0.5rem;
        }

        /* Settings Styles */
        .settings-section {
            margin-bottom: 2rem;
        }

        .settings-title {
            font-weight: 600;
            margin-bottom: 1rem;
            font-size: 1.125rem;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }

        .form-control {
            width: 100%;
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: var(--transition);
        }

        .form-control:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .form-select {
            width: 100%;
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: var(--transition);
        }

        .form-check {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .form-check-input {
            margin-right: 0.5rem;
        }

        .form-range {
            width: 100%;
        }

        .range-value {
            display: inline-block;
            margin-left: 0.5rem;
            font-weight: 500;
        }

        /* Progress Bar */
        .progress-bar {
            width: 100%;
            height: 8px;
            background-color: var(--bg-tertiary);
            border-radius: 4px;
            overflow: hidden;
            margin: 1rem 0;
        }

        .progress-fill {
            height: 100%;
            background-color: var(--primary-color);
            transition: width 0.3s ease;
        }

        /* Detection Settings */
        .detection-settings {
            background-color: var(--bg-tertiary);
            padding: 1rem;
            border-radius: var(--border-radius);
            margin-bottom: 1rem;
        }

        .detection-params {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-top: 1rem;
        }

        /* Responsive Styles */
        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                height: 200px;
                border-right: none;
                border-bottom: 1px solid var(--border-color);
            }

            .editor-content {
                flex-direction: column;
            }

            .crop-list {
                width: 100%;
                height: 200px;
                border-left: none;
                border-top: 1px solid var(--border-color);
            }

            .header {
                padding: 1rem;
            }

            .footer {
                padding: 1rem;
                flex-direction: column;
                gap: 1rem;
            }

            .detection-params {
                grid-template-columns: 1fr;
            }
        }

        /* Utility Classes */
        .hidden {
            display: none !important;
        }

        .text-center {
            text-align: center;
        }

        .mt-1 {
            margin-top: 0.5rem;
        }

        .mt-2 {
            margin-top: 1rem;
        }

        .mb-1 {
            margin-bottom: 0.5rem;
        }

        .mb-2 {
            margin-bottom: 1rem;
        }
    </style>
</head>
<body>
    <div class="app">
        <!-- Header -->
        <header class="header">
            <div class="logo">
                <div class="logo-icon">BDC</div>
                <span>BatchDocCropper</span>
            </div>
            <div class="header-actions">
                <button class="btn-icon" id="theme-toggle" title="Toggle theme">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                </button>
                <button class="btn btn-secondary" id="settings-btn">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="3"></circle>
                        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                    </svg>
                    Settings
                </button>
                <button class="btn btn-primary" id="upload-btn">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="17 8 12 3 7 8"></polyline>
                        <line x1="12" y1="3" x2="12" y2="15"></line>
                    </svg>
                    Upload Files
                </button>
            </div>
        </header>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Sidebar -->
            <div class="sidebar" id="sidebar">
                <div class="sidebar-header">
                    <h3>Files</h3>
                    <div class="file-counter" id="file-counter">0 / 50 files</div>
                </div>
                <div class="file-list" id="file-list">
                    <!-- File items will be dynamically added here -->
                </div>
            </div>

            <!-- Editor -->
            <div class="editor" id="editor">
                <div class="editor-header">
                    <div class="editor-title" id="editor-title">No file selected</div>
                    <div class="editor-actions">
                        <button class="btn btn-secondary" id="detect-btn" disabled>
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M12 2a10 10 0 1 0 10 10 4 4 0 0 1-5-5 4 4 0 0 1-5-5"></path>
                                <path d="M8.5 8.5v.01"></path>
                                <path d="M16 15.5v.01"></path>
                                <path d="M12 12v.01"></path>
                                <path d="M11 17v.01"></path>
                                <path d="M7 14v.01"></path>
                            </svg>
                            Detect Documents
                        </button>
                        <button class="btn btn-secondary" id="add-crop-btn" disabled>
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                                <line x1="12" y1="8" x2="12" y2="16"></line>
                                <line x1="8" y1="12" x2="16" y1="12"></line>
                            </svg>
                            Add Crop
                        </button>
                        <button class="btn btn-secondary" id="reset-crops-btn" disabled>
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="1 4 1 10 7 10"></polyline>
                                <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>
                            </svg>
                            Reset
                        </button>
                    </div>
                </div>
                <div class="editor-content">
                    <div class="canvas-container">
                        <canvas id="editor-canvas"></canvas>
                    </div>
                    <div class="crop-list">
                        <div class="crop-list-header">
                            <h3>Crops</h3>
                            <div id="crop-count">0 crops</div>
                        </div>
                        <div class="crop-items" id="crop-list">
                            <!-- Crop items will be dynamically added here -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Upload Area (shown when no files are uploaded) -->
            <div class="upload-area" id="upload-area">
                <div class="upload-icon">
                    <svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="17 8 12 3 7 8"></polyline>
                        <line x1="12" y1="3" x2="12" y2="15"></line>
                    </svg>
                </div>
                <h2 class="upload-title">Upload Your Files</h2>
                <p class="upload-description">
                    Drag and drop up to 50 images. We'll auto-detect and crop documents/photos inside each page.
                    All processing happens in your browser. Files never leave your device.
                </p>
                <div class="upload-zone" id="upload-zone">
                    <div class="text-center">
                        <p>Drop files here or</p>
                        <button class="btn btn-primary mt-1" id="select-files-btn">Select Files</button>
                    </div>
                    <div class="upload-formats mt-2">
                        Supported formats: JPG, PNG, TIFF (PDF currently not processed)
                    </div>
                </div>
            </div>
        </main>

        <!-- Footer -->
        <footer class="footer">
            <div class="summary" id="batch-summary">No files uploaded</div>
            <button class="btn btn-primary" id="download-btn" disabled>
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                    <polyline points="7 10 12 15 17 10"></polyline>
                    <line x1="12" y1="15" x2="12" y2="3"></line>
                </svg>
                Download Cropped Images (ZIP)
            </button>
        </footer>
    </div>

    <!-- Settings Modal -->
    <div class="modal-overlay hidden" id="settings-modal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">Settings</h3>
                <button class="modal-close" id="settings-close">&times;</button>
            </div>
            <div class="modal-body">
                <div class="settings-section">
                    <h4 class="settings-title">AI Detection Settings</h4>
                    <div class="detection-settings">
                        <div class="form-group">
                            <label class="form-label" for="detection-sensitivity">Detection Sensitivity</label>
                            <input type="range" class="form-range" id="detection-sensitivity" min="1" max="10" value="6">
                            <div class="range-value" id="sensitivity-value">6</div>
                        </div>
                        <div class="detection-params">
                            <div class="form-group">
                                <label class="form-label" for="edge-threshold">Edge Threshold</label>
                                <input type="range" class="form-range" id="edge-threshold" min="10" max="100" value="50">
                                <div class="range-value" id="edge-value">50</div>
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="min-doc-size">Min Document Size</label>
                                <input type="range" class="form-range" id="min-doc-size" min="5" max="50" value="15">
                                <div class="range-value" id="size-value">15%</div>
                            </div>
                        </div>
                        <div class="form-check">
                            <input type="checkbox" class="form-check-input" id="deskew-docs" checked>
                            <label class="form-label" for="deskew-docs">Auto-deskew documents</label>
                        </div>
                        <div class="form-check">
                            <input type="checkbox" class="form-check-input" id="enhance-docs" checked>
                            <label class="form-label" for="enhance-docs">Enhance document quality</label>
                        </div>
                    </div>
                </div>

                <div class="settings-section">
                    <h4 class="settings-title">Output Settings</h4>
                    <div class="form-group">
                        <label class="form-label" for="output-format">Output Format</label>
                        <select class="form-select" id="output-format">
                            <option value="jpg">JPG</option>
                            <option value="png">PNG</option>
                        </select>
                    </div>
                    <div class="form-group" id="jpg-quality-group">
                        <label class="form-label" for="jpg-quality">JPG Quality <span class="range-value" id="jpg-quality-value">90</span>%</label>
                        <input type="range" class="form-range" id="jpg-quality" min="50" max="100" value="90">
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="target-dpi">Target DPI</label>
                        <select class="form-select" id="target-dpi">
                            <option value="72">72 DPI (Screen)</option>
                            <option value="150">150 DPI</option>
                            <option value="300" selected>300 DPI (Print)</option>
                            <option value="600">600 DPI (High Quality)</option>
                        </select>
                    </div>
                    <div class="form-check">
                        <input type="checkbox" class="form-check-input" id="auto-rotate" checked>
                        <label class="form-label" for="auto-rotate">Auto-rotate based on content</label>
                    </div>
                </div>

                <div class="settings-section">
                    <h4 class="settings-title">Processing Mode</h4>
                    <div class="form-group">
                        <div class="form-check">
                            <input type="radio" class="form-check-input" name="processing-mode" id="mode-document" checked>
                            <label class="form-label" for="mode-document">Document Mode (optimized for text, grayscale)</label>
                        </div>
                        <div class="form-check">
                            <input type="radio" class="form-check-input" name="processing-mode" id="mode-photo">
                            <label class="form-label" for="mode-photo">Photo Mode (preserve colors)</label>
                        </div>
                    </div>
                    <div class="form-check">
                        <input type="checkbox" class="form-check-input" id="shadow-cleanup">
                        <label class="form-label" for="shadow-cleanup">Clean shadows and background</label>
                    </div>
                </div>

                <div class="settings-section">
                    <h4 class="settings-title">File Naming</h4>
                    <div class="form-group">
                        <label class="form-label" for="filename-pattern">Filename Pattern</label>
                        <select class="form-select" id="filename-pattern">
                            <option value="{originalName}_{index}">{originalName}_{index}</option>
                            <option value="{batchName}_{fileIndex}_{cropIndex}">{batchName}_{fileIndex}_{cropIndex}</option>
                            <option value="{timestamp}_{index}">{timestamp}_{index}</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="batch-prefix">Batch Prefix</label>
                        <input type="text" class="form-control" id="batch-prefix" placeholder="e.g., ScanBatch">
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="settings-cancel">Cancel</button>
                <button class="btn btn-primary" id="settings-save">Save Settings</button>
            </div>
        </div>
    </div>

    <!-- File Input (hidden) -->
    <input type="file" id="file-input" multiple accept=".jpg,.jpeg,.png,.tiff,.tif" style="display: none;">

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script>
        // Advanced Document Detection Algorithm
        class DocumentDetector {
            constructor() {
                this.canvas = document.createElement('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.worker = this.createWorker();
            }

            createWorker() {
                const blob = new Blob([\`
                    self.onmessage = function(e) {
                        const { imageData, width, height, sensitivity, edgeThreshold, minSize } = e.data;
                        const result = detectDocuments(imageData, width, height, sensitivity, edgeThreshold, minSize);
                        self.postMessage(result);
                    };

                    function detectDocuments(imageData, width, height, sensitivity, edgeThreshold, minSize) {
                        const data = new Uint32Array(imageData);
                        const edges = detectEdges(data, width, height, edgeThreshold);
                        const contours = findContours(edges, width, height);
                        const documents = filterDocuments(contours, width, height, sensitivity, minSize);
                        return documents;
                    }

                    function detectEdges(data, width, height, threshold) {
                        const edges = new Uint8Array(width * height);
                        const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
                        const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
                        
                        for (let y = 1; y < height - 1; y++) {
                            for (let x = 1; x < width - 1; x++) {
                                let gx = 0, gy = 0;
                                
                                for (let ky = -1; ky <= 1; ky++) {
                                    for (let kx = -1; kx <= 1; kx++) {
                                        const pixel = data[(y + ky) * width + (x + kx)];
                                        const r = (pixel >> 16) & 0xff;
                                        const g = (pixel >> 8) & 0xff;
                                        const b = pixel & 0xff;
                                        const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                                        
                                        const kernelIndex = (ky + 1) * 3 + (kx + 1);
                                        gx += gray * sobelX[kernelIndex];
                                        gy += gray * sobelY[kernelIndex];
                                    }
                                }
                                
                                const magnitude = Math.sqrt(gx * gx + gy * gy);
                                edges[y * width + x] = magnitude > threshold ? 255 : 0;
                            }
                        }
                        return edges;
                    }

                    function findContours(edges, width, height) {
                        const visited = new Uint8Array(width * height);
                        const contours = [];
                        
                        for (let y = 0; y < height; y++) {
                            for (let x = 0; x < width; x++) {
                                if (edges[y * width + x] === 255 && !visited[y * width + x]) {
                                    const contour = traceContour(edges, visited, x, y, width, height);
                                    if (contour.length > 10) {
                                        contours.push(contour);
                                    }
                                }
                            }
                        }
                        return contours;
                    }

                    function traceContour(edges, visited, startX, startY, width, height) {
                        const contour = [];
                        const stack = [[startX, startY]];
                        const directions = [[1,0], [1,1], [0,1], [-1,1], [-1,0], [-1,-1], [0,-1], [1,-1]];
                        
                        while (stack.length > 0) {
                            const [x, y] = stack.pop();
                            if (x < 0 || x >= width || y < 0 || y >= height) continue;
                            if (visited[y * width + x] || edges[y * width + x] !== 255) continue;
                            
                            visited[y * width + x] = 1;
                            contour.push([x, y]);
                            
                            for (const [dx, dy] of directions) {
                                stack.push([x + dx, y + dy]);
                            }
                        }
                        return contour;
                    }

                    function filterDocuments(contours, width, height, sensitivity, minSize) {
                        const documents = [];
                        const minArea = (width * height * minSize) / 10000;
                        
                        for (const contour of contours) {
                            if (contour.length < 4) continue;
                            
                            const rect = approximateRectangle(contour);
                            if (!rect) continue;
                            
                            const area = rect.width * rect.height;
                            if (area < minArea) continue;
                            
                            const aspectRatio = Math.max(rect.width, rect.height) / Math.min(rect.width, rect.height);
                            if (aspectRatio > 5) continue;
                            
                            const rectangularity = 1; // simplified
                            
                            if (rectangularity < 0.7) continue;
                            
                            const confidence = calculateConfidence(contour, rect, sensitivity);
                            
                            if (confidence > 0.5) {
                                documents.push({
                                    x: rect.x,
                                    y: rect.y,
                                    width: rect.width,
                                    height: rect.height,
                                    rotation: rect.rotation,
                                    confidence: confidence
                                });
                            }
                        }
                        
                        return documents.sort((a, b) => b.confidence - a.confidence);
                    }

                    function approximateRectangle(contour) {
                        if (contour.length < 4) return null;
                        
                        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                        for (const [x, y] of contour) {
                            minX = Math.min(minX, x);
                            minY = Math.min(minY, y);
                            maxX = Math.max(maxX, x);
                            maxY = Math.max(maxY, y);
                        }
                        
                        return {
                            x: minX,
                            y: minY,
                            width: maxX - minX,
                            height: maxY - minY,
                            rotation: 0
                        };
                    }

                    function calculateConfidence(contour, rect, sensitivity) {
                        const area = rect.width * rect.height;
                        const contourArea = contour.length;
                        const coverage = contourArea / (2 * (rect.width + rect.height));
                        const baseConfidence = Math.min(1, coverage * (sensitivity / 5));
                        return baseConfidence;
                    }
                \`], { type: 'application/javascript' });
                
                return new Worker(URL.createObjectURL(blob));
            }

            async detectDocuments(image, sensitivity = 6, edgeThreshold = 50, minSize = 15) {
                return new Promise((resolve) => {
                    this.canvas.width = image.width;
                    this.canvas.height = image.height;
                    this.ctx.drawImage(image, 0, 0);
                    const imageData = this.ctx.getImageData(0, 0, image.width, image.height);
                    
                    this.worker.postMessage({
                        imageData: imageData.data.buffer,
                        width: image.width,
                        height: image.height,
                        sensitivity: sensitivity,
                        edgeThreshold: edgeThreshold,
                        minSize: minSize
                    }, [imageData.data.buffer]);
                    
                    this.worker.onmessage = (e) => {
                        resolve(e.data);
                    };
                });
            }

            destroy() {
                this.worker.terminate();
            }
        }

        // Enhanced Image Processor with Deskew and Enhancement
        class ImageProcessor {
            static deskewImage(ctx, x, y, width, height, rotation) {
                ctx.save();
                ctx.translate(x + width / 2, y + height / 2);
                ctx.rotate(rotation * Math.PI / 180);
                ctx.translate(-width / 2, -height / 2);
                return ctx;
            }

            static enhanceDocument(ctx, width, height, mode) {
                const imageData = ctx.getImageData(0, 0, width, height);
                const data = imageData.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    if (mode === 'document') {
                        const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                        const enhanced = this.enhanceContrast(gray, 50, 200);
                        data[i] = data[i + 1] = data[i + 2] = enhanced;
                    } else {
                        data[i] = this.enhanceColor(data[i]);
                        data[i + 1] = this.enhanceColor(data[i + 1]);
                        data[i + 2] = this.enhanceColor(data[i + 2]);
                    }
                    
                    if (data[i] < 50 && data[i + 1] < 50 && data[i + 2] < 50) {
                        const factor = 2;
                        data[i] = Math.min(255, data[i] * factor);
                        data[i + 1] = Math.min(255, data[i + 1] * factor);
                        data[i + 2] = Math.min(255, data[i + 2] * factor);
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
                return ctx;
            }

            static enhanceContrast(value, min, max) {
                return Math.min(255, Math.max(0, (value - min) * 255 / (max - min)));
            }

            static enhanceColor(value) {
                return 255 * (1 / (1 + Math.exp(-(value - 128) / 32)));
            }

            static removeBackground(ctx, width, height) {
                const imageData = ctx.getImageData(0, 0, width, height);
                const data = imageData.data;
                const histogram = new Array(256).fill(0);
                for (let i = 0; i < data.length; i += 4) {
                    const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                    histogram[Math.floor(gray)]++;
                }
                let maxCount = 0;
                let bgColor = 0;
                for (let i = 0; i < 256; i++) {
                    if (histogram[i] > maxCount) {
                        maxCount = histogram[i];
                        bgColor = i;
                    }
                }
                for (let i = 0; i < data.length; i += 4) {
                    const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                    if (Math.abs(gray - bgColor) < 30) {
                        data[i] = data[i + 1] = data[i + 2] = 255;
                    }
                }
                ctx.putImageData(imageData, 0, 0);
                return ctx;
            }
        }

        // Main application state
        const appState = {
            files: [],
            currentFileIndex: -1,
            crops: [],
            currentCropIndex: -1,
            isDrawing: false,
            manualMode: false,
            startX: 0,
            startY: 0,
            currentImage: null,
            detector: new DocumentDetector(),
            settings: {
                outputFormat: 'jpg',
                jpgQuality: 90,
                targetDpi: 300,
                autoRotate: true,
                processingMode: 'document',
                shadowCleanup: false,
                filenamePattern: '{originalName}_{index}',
                batchPrefix: '',
                detectionSensitivity: 6,
                edgeThreshold: 50,
                minDocSize: 15,
                deskewDocs: true,
                enhanceDocs: true
            },
            theme: localStorage.getItem('theme') || 'light'
        };

        // DOM Elements
        const elements = {
            uploadArea: document.getElementById('upload-area'),
            sidebar: document.getElementById('sidebar'),
            editor: document.getElementById('editor'),
            fileList: document.getElementById('file-list'),
            editorCanvas: document.getElementById('editor-canvas'),
            cropList: document.getElementById('crop-list'),
            themeToggle: document.getElementById('theme-toggle'),
            settingsBtn: document.getElementById('settings-btn'),
            uploadBtn: document.getElementById('upload-btn'),
            selectFilesBtn: document.getElementById('select-files-btn'),
            detectBtn: document.getElementById('detect-btn'),
            addCropBtn: document.getElementById('add-crop-btn'),
            resetCropsBtn: document.getElementById('reset-crops-btn'),
            downloadBtn: document.getElementById('download-btn'),
            fileInput: document.getElementById('file-input'),
            uploadZone: document.getElementById('upload-zone'),
            fileCounter: document.getElementById('file-counter'),
            editorTitle: document.getElementById('editor-title'),
            cropCount: document.getElementById('crop-count'),
            batchSummary: document.getElementById('batch-summary'),
            settingsModal: document.getElementById('settings-modal'),
            settingsClose: document.getElementById('settings-close'),
            settingsCancel: document.getElementById('settings-cancel'),
            settingsSave: document.getElementById('settings-save'),
            outputFormat: document.getElementById('output-format'),
            jpgQuality: document.getElementById('jpg-quality'),
            jpgQualityValue: document.getElementById('jpg-quality-value'),
            jpgQualityGroup: document.getElementById('jpg-quality-group'),
            targetDpi: document.getElementById('target-dpi'),
            autoRotate: document.getElementById('auto-rotate'),
            modeDocument: document.getElementById('mode-document'),
            modePhoto: document.getElementById('mode-photo'),
            shadowCleanup: document.getElementById('shadow-cleanup'),
            filenamePattern: document.getElementById('filename-pattern'),
            batchPrefix: document.getElementById('batch-prefix'),
            detectionSensitivity: document.getElementById('detection-sensitivity'),
            sensitivityValue: document.getElementById('sensitivity-value'),
            edgeThreshold: document.getElementById('edge-threshold'),
            edgeValue: document.getElementById('edge-value'),
            minDocSize: document.getElementById('min-doc-size'),
            sizeValue: document.getElementById('size-value'),
            deskewDocs: document.getElementById('deskew-docs'),
            enhanceDocs: document.getElementById('enhance-docs')
        };

        const canvasCtx = elements.editorCanvas.getContext('2d');

        function init() {
            setTheme(appState.theme);
            loadSettings();
            setupEventListeners();
            updateUI();
        }

        function setupEventListeners() {
            elements.themeToggle.addEventListener('click', toggleTheme);

            elements.uploadBtn.addEventListener('click', () => elements.fileInput.click());
            elements.selectFilesBtn.addEventListener('click', () => elements.fileInput.click());
            elements.fileInput.addEventListener('change', handleFileSelect);
            elements.uploadZone.addEventListener('dragover', handleDragOver);
            elements.uploadZone.addEventListener('dragleave', handleDragLeave);
            elements.uploadZone.addEventListener('drop', handleFileDrop);

            elements.detectBtn.addEventListener('click', detectDocumentsForCurrent);
            elements.addCropBtn.addEventListener('click', startManualCrop);
            elements.resetCropsBtn.addEventListener('click', resetCrops);
            elements.downloadBtn.addEventListener('click', downloadAllCrops);

            elements.editorCanvas.addEventListener('mousedown', startDrawing);
            elements.editorCanvas.addEventListener('mousemove', draw);
            elements.editorCanvas.addEventListener('mouseup', stopDrawing);
            elements.editorCanvas.addEventListener('mouseleave', stopDrawing);

            elements.editorCanvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            elements.editorCanvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            elements.editorCanvas.addEventListener('touchend', handleTouchEnd);

            elements.settingsBtn.addEventListener('click', openSettings);
            elements.settingsClose.addEventListener('click', closeSettings);
            elements.settingsCancel.addEventListener('click', closeSettings);
            elements.settingsSave.addEventListener('click', saveSettings);

            elements.outputFormat.addEventListener('change', updateJpgQualityVisibility);
            elements.jpgQuality.addEventListener('input', updateJpgQualityValue);

            elements.detectionSensitivity.addEventListener('input', updateSensitivityValue);
            elements.edgeThreshold.addEventListener('input', updateEdgeValue);
            elements.minDocSize.addEventListener('input', updateSizeValue);
        }

        // Theme
        function setTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme === 'dark' ? 'dark' : 'light');
            appState.theme = theme;
            localStorage.setItem('theme', theme);
        }

        function toggleTheme() {
            const newTheme = appState.theme === 'light' ? 'dark' : 'light';
            setTheme(newTheme);
        }

        // File handling
        function handleFileSelect(e) {
            const files = Array.from(e.target.files || []);
            addFiles(files);
            elements.fileInput.value = '';
        }

        function handleDragOver(e) {
            e.preventDefault();
            elements.uploadZone.classList.add('drag-over');
        }

        function handleDragLeave(e) {
            e.preventDefault();
            elements.uploadZone.classList.remove('drag-over');
        }

        function handleFileDrop(e) {
            e.preventDefault();
            elements.uploadZone.classList.remove('drag-over');
            const files = Array.from(e.dataTransfer.files || []);
            addFiles(files);
        }

        function addFiles(files) {
            const remainingSlots = 50 - appState.files.length;
            const toAdd = files.slice(0, remainingSlots);

            toAdd.forEach((file) => {
                if (!file.type.startsWith('image/')) {
                    if (file.name.toLowerCase().endsWith('.pdf')) {
                        alert('PDF files are currently not processed in this version. Only images are added.');
                    }
                    return;
                }

                const id = generateId();
                const fileObj = {
                    id,
                    file,
                    name: file.name,
                    size: file.size,
                    type: file.type,
                    status: 'waiting',
                    crops: [],
                    thumbDataUrl: null,
                    imageElement: null
                };
                appState.files.push(fileObj);
                createThumbnailForFile(fileObj);
            });

            if (appState.files.length > 0 && appState.currentFileIndex === -1) {
                selectFile(0);
            }

            updateUI();
            renderFileList();
        }

        function createThumbnailForFile(fileObj) {
            const reader = new FileReader();
            reader.onload = (e) => {
                fileObj.thumbDataUrl = e.target.result;
                renderFileList();
            };
            reader.readAsDataURL(fileObj.file);
        }

        function renderFileList() {
            elements.fileList.innerHTML = '';
            appState.files.forEach((file, index) => {
                const item = document.createElement('div');
                item.className = 'file-item' + (index === appState.currentFileIndex ? ' active' : '');
                item.dataset.index = index;

                const thumb = document.createElement('div');
                thumb.className = 'file-thumbnail';
                if (file.thumbDataUrl) {
                    const img = document.createElement('img');
                    img.src = file.thumbDataUrl;
                    thumb.appendChild(img);
                } else {
                    thumb.textContent = 'IMG';
                }

                const info = document.createElement('div');
                info.className = 'file-info';

                const nameEl = document.createElement('div');
                nameEl.className = 'file-name';
                nameEl.textContent = file.name;

                const detailsEl = document.createElement('div');
                detailsEl.className = 'file-details';

                const sizeKb = Math.round(file.size / 1024);
                const left = document.createElement('span');
                left.textContent = sizeKb + ' KB';

                const status = document.createElement('span');
                const badge = document.createElement('span');
                badge.className = 'status-badge ' + getStatusClass(file.status);
                badge.textContent = file.status.toUpperCase();
                status.appendChild(badge);

                detailsEl.appendChild(left);
                detailsEl.appendChild(status);

                info.appendChild(nameEl);
                info.appendChild(detailsEl);

                item.appendChild(thumb);
                item.appendChild(info);

                item.addEventListener('click', () => selectFile(index));

                elements.fileList.appendChild(item);
            });
        }

        function getStatusClass(status) {
            switch (status) {
                case 'waiting': return 'status-waiting';
                case 'processing': return 'status-processing';
                case 'done': return 'status-done';
                case 'error': return 'status-error';
                default: return 'status-waiting';
            }
        }

        function selectFile(index) {
            if (index < 0 || index >= appState.files.length) return;
            appState.currentFileIndex = index;
            const file = appState.files[index];
            appState.crops = file.crops.slice();
            appState.currentCropIndex = -1;
            elements.editorTitle.textContent = file.name;
            loadImageForCurrentFile();
            renderFileList();
            updateCropsList();
            updateUI();
        }

        function loadImageForCurrentFile() {
            const fileObj = appState.files[appState.currentFileIndex];
            if (!fileObj) return;

            if (fileObj.imageElement) {
                appState.currentImage = fileObj.imageElement;
                drawImageAndCrops();
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    fileObj.imageElement = img;
                    appState.currentImage = img;
                    elements.editorCanvas.width = img.width;
                    elements.editorCanvas.height = img.height;
                    drawImageAndCrops();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(fileObj.file);
        }

        function updateFileItem(fileObj) {
            // simple: re-render whole list
            renderFileList();
        }

        // Crops UI
        function updateCropsList() {
            elements.cropList.innerHTML = '';
            appState.crops.forEach((crop, index) => {
                const item = document.createElement('div');
                item.className = 'crop-item' + (index === appState.currentCropIndex ? ' active' : '');
                item.dataset.index = index;

                const thumb = document.createElement('div');
                thumb.className = 'crop-thumbnail';
                thumb.textContent = (index + 1).toString();

                const info = document.createElement('div');
                info.className = 'crop-info';

                const nameEl = document.createElement('div');
                nameEl.className = 'crop-name';
                nameEl.textContent = crop.name || ('Crop ' + (index + 1));

                const detailsEl = document.createElement('div');
                detailsEl.className = 'crop-details';
                detailsEl.textContent = \`x:\${crop.x}, y:\${crop.y}, w:\${crop.width}, h:\${crop.height}\`;

                info.appendChild(nameEl);
                info.appendChild(detailsEl);

                item.appendChild(thumb);
                item.appendChild(info);

                item.addEventListener('click', () => {
                    appState.currentCropIndex = index;
                    updateCropsList();
                    drawImageAndCrops();
                });

                elements.cropList.appendChild(item);
            });

            elements.cropCount.textContent = appState.crops.length + ' crops';

            if (appState.currentFileIndex >= 0) {
                appState.files[appState.currentFileIndex].crops = appState.crops.slice();
            }
        }

        function drawImageAndCrops(previewRect = null) {
            if (!appState.currentImage) {
                canvasCtx.clearRect(0, 0, elements.editorCanvas.width, elements.editorCanvas.height);
                return;
            }

            const img = appState.currentImage;
            elements.editorCanvas.width = img.width;
            elements.editorCanvas.height = img.height;

            canvasCtx.clearRect(0, 0, img.width, img.height);
            canvasCtx.drawImage(img, 0, 0);

            // existing crops
            canvasCtx.lineWidth = 2;
            appState.crops.forEach((crop, index) => {
                canvasCtx.strokeStyle = (index === appState.currentCropIndex) ? '#3a86ff' : '#06d6a0';
                canvasCtx.strokeRect(crop.x, crop.y, crop.width, crop.height);
            });

            // preview
            if (previewRect) {
                canvasCtx.strokeStyle = '#ef476f';
                canvasCtx.setLineDash([6, 4]);
                canvasCtx.strokeRect(previewRect.x, previewRect.y, previewRect.width, previewRect.height);
                canvasCtx.setLineDash([]);
            }
        }

        // AI Detection
        async function detectDocumentsForCurrent() {
            if (appState.currentFileIndex < 0) return;
            const file = appState.files[appState.currentFileIndex];
            if (!file) return;

            file.status = 'processing';
            updateFileItem(file);

            try {
                if (!file.imageElement) {
                    await new Promise((resolve) => {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            const img = new Image();
                            img.onload = () => {
                                file.imageElement = img;
                                resolve();
                            };
                            img.src = e.target.result;
                        };
                        reader.readAsDataURL(file.file);
                    });
                }

                const img = file.imageElement;
                const documents = await appState.detector.detectDocuments(
                    img,
                    appState.settings.detectionSensitivity,
                    appState.settings.edgeThreshold,
                    appState.settings.minDocSize
                );

                file.crops = documents.map((doc, index) => ({
                    id: generateId(),
                    name: \`Document \${index + 1}\`,
                    x: doc.x,
                    y: doc.y,
                    width: doc.width,
                    height: doc.height,
                    rotation: doc.rotation || 0,
                    confidence: doc.confidence || 1
                }));

                file.status = 'done';

                if (appState.files[appState.currentFileIndex]?.id === file.id) {
                    appState.crops = file.crops.slice();
                    appState.currentCropIndex = -1;
                    updateCropsList();
                    drawImageAndCrops();
                }

                updateFileItem(file);
                updateUI();
            } catch (err) {
                console.error('Document detection failed:', err);
                file.status = 'error';
                updateFileItem(file);
                updateUI();
            }
        }

        // Crop processing
        function processCrop(crop, originalImage, index) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                let ctx = canvas.getContext('2d');
                
                canvas.width = crop.width;
                canvas.height = crop.height;
                
                if (appState.settings.deskewDocs && crop.rotation && crop.rotation !== 0) {
                    ctx = ImageProcessor.deskewImage(ctx, 0, 0, crop.width, crop.height, crop.rotation);
                }

                ctx.drawImage(
                    originalImage,
                    crop.x, crop.y, crop.width, crop.height,
                    0, 0, crop.width, crop.height
                );
                
                if (appState.settings.enhanceDocs) {
                    ctx = ImageProcessor.enhanceDocument(
                        ctx, 
                        crop.width, 
                        crop.height, 
                        appState.settings.processingMode
                    );
                }
                
                if (appState.settings.shadowCleanup) {
                    ctx = ImageProcessor.removeBackground(ctx, crop.width, crop.height);
                }
                
                const dataUrl = canvas.toDataURL(
                    'image/' + appState.settings.outputFormat,
                    appState.settings.outputFormat === 'jpg' ? appState.settings.jpgQuality / 100 : 1
                );
                
                resolve({
                    dataUrl: dataUrl,
                    filename: generateFilename(appState.files[appState.currentFileIndex], crop, index)
                });
            });
        }

        async function downloadAllCrops() {
            const totalCrops = appState.files.reduce((sum, f) => sum + f.crops.length, 0);
            if (totalCrops === 0) return;

            const zip = new JSZip();
            let processedCount = 0;
            elements.downloadBtn.disabled = true;
            elements.downloadBtn.textContent = \`Processing... (0/\${totalCrops})\`;

            for (let fileIndex = 0; fileIndex < appState.files.length; fileIndex++) {
                const file = appState.files[fileIndex];
                if (!file.crops || file.crops.length === 0) continue;

                if (!file.imageElement) {
                    await new Promise((resolve) => {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            const img = new Image();
                            img.onload = () => {
                                file.imageElement = img;
                                resolve();
                            };
                            img.src = e.target.result;
                        };
                        reader.readAsDataURL(file.file);
                    });
                }

                const img = file.imageElement;

                for (let i = 0; i < file.crops.length; i++) {
                    const crop = file.crops[i];
                    appState.currentFileIndex = fileIndex; // for filename pattern
                    const result = await processCrop(crop, img, i);
                    const base64Data = result.dataUrl.split(',')[1];
                    zip.file(result.filename, base64Data, { base64: true });
                    processedCount++;
                    elements.downloadBtn.textContent = \`Processing... (\${processedCount}/\${totalCrops})\`;
                }
            }

            const content = await zip.generateAsync({ type: 'blob' });
            const today = new Date().toISOString().slice(0, 10);
            saveAs(content, \`BatchDocCropper_\${today}.zip\`);

            elements.downloadBtn.disabled = false;
            elements.downloadBtn.innerHTML = \`
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                    <polyline points="7 10 12 15 17 10"></polyline>
                    <line x1="12" y1="15" x2="12" y2="3"></line>
                </svg>
                Download Cropped Images (ZIP)
            \`;
        }

        // Manual crop
        function startManualCrop() {
            if (appState.currentFileIndex < 0 || !appState.currentImage) return;
            appState.manualMode = true;
        }

        function getCanvasCoords(evt) {
            const rect = elements.editorCanvas.getBoundingClientRect();
            const x = (evt.clientX - rect.left) * (elements.editorCanvas.width / rect.width);
            const y = (evt.clientY - rect.top) * (elements.editorCanvas.height / rect.height);
            return { x, y };
        }

        function startDrawing(evt) {
            if (!appState.manualMode || !appState.currentImage) return;
            evt.preventDefault();
            appState.isDrawing = true;
            const { x, y } = getCanvasCoords(evt);
            appState.startX = x;
            appState.startY = y;
        }

        function draw(evt) {
            if (!appState.isDrawing || !appState.currentImage) return;
            evt.preventDefault();
            const { x, y } = getCanvasCoords(evt);
            const rect = {
                x: Math.min(appState.startX, x),
                y: Math.min(appState.startY, y),
                width: Math.abs(x - appState.startX),
                height: Math.abs(y - appState.startY)
            };
            drawImageAndCrops(rect);
        }

        function stopDrawing(evt) {
            if (!appState.isDrawing || !appState.currentImage) return;
            evt && evt.preventDefault();
            appState.isDrawing = false;

            const endEvt = evt || window.event;
            const { x, y } = endEvt.clientX ? getCanvasCoords(endEvt) : { x: appState.startX, y: appState.startY };
            const rect = {
                x: Math.min(appState.startX, x),
                y: Math.min(appState.startY, y),
                width: Math.abs(x - appState.startX),
                height: Math.abs(y - appState.startY)
            };

            if (rect.width > 5 && rect.height > 5) {
                const crop = {
                    id: generateId(),
                    name: \`Crop \${appState.crops.length + 1}\`,
                    x: Math.round(rect.x),
                    y: Math.round(rect.y),
                    width: Math.round(rect.width),
                    height: Math.round(rect.height),
                    rotation: 0,
                    confidence: 1
                };
                appState.crops.push(crop);
                appState.currentCropIndex = appState.crops.length - 1;
                updateCropsList();
            }
            appState.manualMode = false;
            drawImageAndCrops();
            updateUI();
        }

        // Touch handlers
        function handleTouchStart(e) {
            if (!appState.manualMode) return;
            e.preventDefault();
            const touch = e.touches[0];
            startDrawing({ clientX: touch.clientX, clientY: touch.clientY, preventDefault: () => {} });
        }

        function handleTouchMove(e) {
            if (!appState.isDrawing) return;
            e.preventDefault();
            const touch = e.touches[0];
            draw({ clientX: touch.clientX, clientY: touch.clientY, preventDefault: () => {} });
        }

        function handleTouchEnd(e) {
            if (!appState.isDrawing) return;
            e.preventDefault();
            stopDrawing();
        }

        function resetCrops() {
            if (appState.currentFileIndex < 0) return;
            appState.crops = [];
            appState.currentCropIndex = -1;
            appState.files[appState.currentFileIndex].crops = [];
            updateCropsList();
            drawImageAndCrops();
            updateUI();
        }

        // Settings
        function loadSettings() {
            try {
                const saved = localStorage.getItem('batchDocCropperSettings');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    Object.assign(appState.settings, parsed);
                }
            } catch (e) {
                console.warn('Could not load settings', e);
            }

            elements.outputFormat.value = appState.settings.outputFormat;
            elements.jpgQuality.value = appState.settings.jpgQuality;
            elements.jpgQualityValue.textContent = appState.settings.jpgQuality;

            elements.targetDpi.value = String(appState.settings.targetDpi);
            elements.autoRotate.checked = appState.settings.autoRotate;
            elements.modeDocument.checked = appState.settings.processingMode === 'document';
            elements.modePhoto.checked = appState.settings.processingMode === 'photo';
            elements.shadowCleanup.checked = appState.settings.shadowCleanup;
            elements.filenamePattern.value = appState.settings.filenamePattern;
            elements.batchPrefix.value = appState.settings.batchPrefix;

            elements.detectionSensitivity.value = appState.settings.detectionSensitivity;
            elements.edgeThreshold.value = appState.settings.edgeThreshold;
            elements.minDocSize.value = appState.settings.minDocSize;
            elements.deskewDocs.checked = appState.settings.deskewDocs;
            elements.enhanceDocs.checked = appState.settings.enhanceDocs;

            updateJpgQualityVisibility();
            updateSensitivityValue();
            updateEdgeValue();
            updateSizeValue();
        }

        function openSettings() {
            elements.settingsModal.classList.remove('hidden');
        }

        function closeSettings() {
            elements.settingsModal.classList.add('hidden');
        }

        function saveSettings() {
            appState.settings.outputFormat = elements.outputFormat.value;
            appState.settings.jpgQuality = parseInt(elements.jpgQuality.value, 10);
            appState.settings.targetDpi = parseInt(elements.targetDpi.value, 10);
            appState.settings.autoRotate = elements.autoRotate.checked;
            appState.settings.processingMode = elements.modePhoto.checked ? 'photo' : 'document';
            appState.settings.shadowCleanup = elements.shadowCleanup.checked;
            appState.settings.filenamePattern = elements.filenamePattern.value;
            appState.settings.batchPrefix = elements.batchPrefix.value;

            appState.settings.detectionSensitivity = parseInt(elements.detectionSensitivity.value, 10);
            appState.settings.edgeThreshold = parseInt(elements.edgeThreshold.value, 10);
            appState.settings.minDocSize = parseInt(elements.minDocSize.value, 10);
            appState.settings.deskewDocs = elements.deskewDocs.checked;
            appState.settings.enhanceDocs = elements.enhanceDocs.checked;

            localStorage.setItem('batchDocCropperSettings', JSON.stringify(appState.settings));
            closeSettings();
        }

        function updateJpgQualityVisibility() {
            if (elements.outputFormat.value === 'jpg') {
                elements.jpgQualityGroup.style.display = 'block';
            } else {
                elements.jpgQualityGroup.style.display = 'none';
            }
        }

        function updateJpgQualityValue() {
            elements.jpgQualityValue.textContent = elements.jpgQuality.value;
        }

        // AI Detection Slider helpers
        function updateSensitivityValue() {
            elements.sensitivityValue.textContent = elements.detectionSensitivity.value;
        }

        function updateEdgeValue() {
            elements.edgeValue.textContent = elements.edgeThreshold.value;
        }

        function updateSizeValue() {
            elements.sizeValue.textContent = elements.minDocSize.value + '%';
        }

        // UI state
        function updateUI() {
            elements.fileCounter.textContent = appState.files.length + ' / 50 files';

            const totalCrops = appState.files.reduce((sum, f) => sum + (f.crops ? f.crops.length : 0), 0);
            elements.batchSummary.textContent = appState.files.length === 0
                ? 'No files uploaded'
                : \`\${appState.files.length} file(s), \${totalCrops} crop(s)\`;

            const hasFile = appState.currentFileIndex >= 0 && appState.files[appState.currentFileIndex];
            elements.detectBtn.disabled = !hasFile;
            elements.addCropBtn.disabled = !hasFile;
            elements.resetCropsBtn.disabled = !hasFile || appState.crops.length === 0;
            elements.downloadBtn.disabled = totalCrops === 0;

            // Show editor + sidebar only when there are files
            if (appState.files.length === 0) {
                elements.sidebar.classList.add('hidden');
                elements.editor.classList.add('hidden');
                elements.uploadArea.classList.remove('hidden');
            } else {
                elements.sidebar.classList.remove('hidden');
                elements.editor.classList.remove('hidden');
                elements.uploadArea.classList.add('hidden');
            }
        }

        // Helpers
        function generateId() {
            return 'id-' + Math.random().toString(36).substr(2, 9) + '-' + Date.now();
        }

        function generateFilename(fileObj, crop, index) {
            const pattern = appState.settings.filenamePattern || '{originalName}_{index}';
            const originalNameWithoutExt = (fileObj.name || 'image').replace(/\.[^/.]+$/, '');
            const timestamp = new Date().toISOString().replace(/[-:.]/g, '').slice(0, 14);
            const batchName = appState.settings.batchPrefix || 'Batch';

            const fileIndex = appState.files.indexOf(fileObj) + 1;
            const cropIndex = index + 1;

            const replaced = pattern
                .replace(/\{originalName\}/g, originalNameWithoutExt)
                .replace(/\{index\}/g, cropIndex)
                .replace(/\{batchName\}/g, batchName)
                .replace(/\{fileIndex\}/g, fileIndex)
                .replace(/\{cropIndex\}/g, cropIndex)
                .replace(/\{timestamp\}/g, timestamp);

            const ext = appState.settings.outputFormat === 'png' ? '.png' : '.jpg';
            return replaced + ext;
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
